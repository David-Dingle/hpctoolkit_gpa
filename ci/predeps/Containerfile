ARG SPACKOS
ARG BASE
ARG TARGETOS
ARG TARGETARCH

# Preparation stage: Build all the dependencies with Spack
# TODO: Freeze this to a release once 0.21.0 is released
FROM ghcr.io/spack/$SPACKOS:latest as spackbuild

# Copy in the common Spack configuration, for the install tree and such
COPY spack/ /etc/spack/

# Copy in the environment, and possibly modify it depending on the mode
COPY spack.yaml /opt/environment/spack.yaml
ARG VERMODE=latest
RUN \
  case "$VERMODE" in \
  latest) \
    sed -E -i '/LATEST: @/ s/@[a-zA-Z0-9._-]+[,:a-zA-Z0-9._-]*(.*)LATEST: @([a-zA-Z0-9._-]+[,:a-zA-Z0-9._-]*)/@\2\1/' /opt/environment/spack.yaml; \
    ;; \
  minimum) \
    sed -E -i 's/@([a-zA-Z0-9._-]+)[,:a-zA-Z0-9._-]*/@\1/g' /opt/environment/spack.yaml; \
    ;; \
  *) \
    echo "Bad VERMODE: $VERMODE" >&2; \
    exit 1; \
    ;; \
  esac

# Install all the packages we want, using the environment. We use an extra Makefile to add a
# post-install hook that pushes the resulting packages to various buildcaches.
COPY Makefile /opt/environment/Makefile
ARG REMOTE_CACHE_MIRROR=
RUN --mount=type=secret,id=spack_mirrors,target=/root/.spack/mirrors.yaml \
    --mount=type=cache,target=/mnt/cache/spack-bin,sharing=locked \
    --mount=type=cache,target=/mnt/cache/spack-src \
  export PATH=/opt/spack/bin:"$PATH" \
  && spack -D /opt/environment concretize \
  && spack -D /opt/environment env depfile --generator make --make-prefix predeps \
      -o /opt/environment/spack.mk \
  && make -j$(nproc) -C /opt/environment --output-sync=recurse \
      SPACK_INSTALL_FLAGS=--no-check-signature REMOTE_CACHE_MIRROR="$REMOTE_CACHE_MIRROR" \
  && spack -D /opt/environment buildcache push --unsigned --fail-fast --update-index local-cache \
  && spack -D /opt/environment gc -y

# Generate a Meson native file that provides access to the installed packages, using Jinja2
COPY j2-spack.py spack_env.ini.j2 /tmp/
RUN \
  export PATH=/opt/spack/bin:"$PATH" \
  && py="$(spack -D /opt/environment find --format='{prefix}' python)/bin/python" \
  && "$py" -m venv /tmp/venv && /tmp/venv/bin/python -m pip install 'Jinja2>=3.1,<4' \
  && /tmp/venv/bin/python /tmp/j2-spack.py /tmp/spack_env.ini.j2 /usr/share/meson/native/spack_env.ini \
  && rm -r /tmp/j2-spack.py /tmp/spack_env.ini.j2 /tmp/venv


# Final stage
FROM $BASE

# Some images set problematic environment variables. Wipe those out first for safety.
ENV PYTHONPATH=
ENV PKG_CONFIG_PATH=
ENV PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
ENV CPATH=
ENV LIBRARY_PATH=
ENV LD_LIBRARY_PATH=
ENV CMAKE_PREFIX_PATH=

# Install the required packages along with all the Meson native files for system bits
COPY native/ /usr/share/meson/native/
RUN --mount=type=bind,target=/src/context \
  /src/context/install-os-packages.sh

# Install a up-to-date versions of Meson and Ninja, using a suitable Python
RUN --mount=type=bind,target=/src/context \
  /src/context/best-python.sh -m pip install 'meson[ninja]>=1.1.0,<2'

# Copy in the Spack-built dependencies etc. from the previous stage
COPY --from=spackbuild /opt/software /opt/software
COPY --from=spackbuild /opt/environment /opt/environment
COPY --from=spackbuild /usr/share/meson/native/spack_env.ini /usr/share/meson/native/image.ini

# Merge together the "patch" Meson native files to produce the final native file for the image.
RUN --mount=type=bind,target=/src/context \
  do_patch() { \
    if test -e /usr/share/meson/native/"$1".patch.ini; then \
      /src/context/best-python.sh /src/context/patch-native.py \
        /usr/share/meson/native/image.ini /usr/share/meson/native/"$1".patch.ini \
      && rm /usr/share/meson/native/"$1".patch.ini; \
    fi; \
  } \
  && do_patch cuda \
  && do_patch rocm \
  && do_patch level-zero \
  && do_patch gtpin \
  && ! test -e /usr/share/meson/native/*.patch.ini

# At this point the image should be complete. Test the image before continuing to ensure it
# actually does in fact work as intended. We play some tricks with bind-mounting to keep from
# leaving behind any mark on the image here.
# TODO: Currently the project_dir bind-mount needs to be rw, because Autotools.
RUN --mount=type=bind,target=/src/context \
    --mount=type=bind,from=project_dir,target=/src/hpctoolkit,rw \
    --mount=type=bind,from=scratch,target=/tmp/tmpdir,rw \
  /src/context/verify-image.sh /src/hpctoolkit /tmp/tmpdir/builddir

# Clean up empty directories created by bind-mounts
RUN \
  rm -rfv /src/context /tmp/tmpdir /src/hpctoolkit \
  && rmdir --ignore-fail-on-non-empty /src
