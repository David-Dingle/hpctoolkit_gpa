# NB: This is a crazy pipeline to dodge fundamental flaws in Spack:
#   - `spack ci` doesn't work on multiple environments. This means we have to
#     generate one pipeline per environment concretization.
#   - Spack has to be gently massaged / heavily tainted to cross-concretize correctly.
#     This means operations spanning multiple OSs, like concretization, need to be
#     spread out across multiple jobs and containers... and thus pipelines.
#   - Spack environments are unable to unify specs in a stable and controlled manner,
#     either all specs are concretized together (and views are possible), or
#     some to none are (and views are likely to fail). So we need multiple envionments
#     to properly express our testing dependencies.
#
# In short, if done the correct and straightforward way, we would have a combinatorial
# explosion of jobs and pipelines in this file. This would be obtuse and a pain to
# maintain. To avoid that, we instead manipulate the JSON Spack uses to maintain concrete
# environments in rather atrocious ways and trick it into doing what we want.
# See comments below for more details.

# Concretize all the environments under various combinations of OS and arch.
concretize_deps.amd64:
  stage: dependencies
  extends: .spack
  image: registry.gitlab.com/hpctoolkit/ci-images/$IMAGE:$ARCH
  tags: [docker, linux/$ARCH]
  needs: []

  variables:
    ARCH: amd64
  parallel:
    matrix:
    - IMAGE:
      - almalinux8
      - centos7
      - fedora36
      - leap15
    # Some images have multiple compilers, in those cases we choose one to concretize to
    - IMAGE: ubuntu20.04
      CI_SPACK_CC: gcc@9

  script:
  - |
    case "$ARCH" in
    amd64) CI_SPACK_ARCH=x86_64_v3; ;;
    arm64) CI_SPACK_ARCH=aarch64; ;;
    *)
      echo "Invalid ARCH: $ARCH"
      exit 1
      ;;
    esac
    echo "Will concretize for generic target $CI_SPACK_ARCH"
  # Setup the Spack configuration for concretization:
  #   Copy the base-mirrors configuration from the cache environment
  - spack -e ci/dependencies/merged-cache/ config get mirrors | tee mirrors.yaml
  - spack config --scope site add --file mirrors.yaml
  - spack buildcache keys --install --trust
  #   Always concretize to the generic target instead of a specific one
  - spack config --scope site add "packages:all:target:['$CI_SPACK_ARCH']"
  #   Always concretize to a particular compiler if there are multiple
  - test -n "$CI_SPACK_CC" && spack config --scope site add "packages:all:compiler:['$CI_SPACK_CC']"
  # Set up concrete environments named by the OS and ARCH
  - OS=$(spack arch --operating-system)
  - mkdir -p ci/dependencies/minimum/c/$OS/$ARCH/ && cp -r ci/dependencies/minimum/{spack.yaml,config} ci/dependencies/minimum/c/$OS/$ARCH/
  - mkdir -p ci/dependencies/latest/c/$OS/$ARCH/ && cp -r ci/dependencies/latest/{spack.yaml,config} ci/dependencies/latest/c/$OS/$ARCH/
  # Concretize each of the environments in turn, into subdirectories named by the OS and ARCH
  - spack buildcache list > /dev/null  # Manually update the buildcache index to make the concretization faster
  - >-
    ci/scripts/all_at_once.py 1
    "spack -e ci/dependencies/minimum/c/$OS/$ARCH/ -d concretize --reuse"
    "spack -e ci/dependencies/latest/c/$OS/$ARCH/ -d concretize --reuse"

  artifacts:
    paths:
    - ci/dependencies/{minimum,latest}/c/*/*/{spack.lock,spack.yaml,config/}

concretize_deps.arm64:
  extends: concretize_deps.amd64
  variables:
    ARCH: arm64
  parallel:
    matrix:
    # - IMAGE:
    #   - almalinux8
    #   - fedora36
    - IMAGE: ubuntu20.04
      CI_SPACK_CC: gcc@9


# Fuse all the environments into one, and generate the pipeline for it
generate_deps.amd64:
  stage: dependencies
  extends: .spack
  needs:
  - 'concretize_deps.amd64: [almalinux8]'
  - 'concretize_deps.amd64: [centos7]'
  - 'concretize_deps.amd64: [fedora36]'
  - 'concretize_deps.amd64: [leap15]'
  - 'concretize_deps.amd64: [ubuntu20.04, gcc@9]'

  script:
  # Fuse the now-concrete environments into one
  - python3 ci/dependencies/merged-cache/fuse.py
    ci/dependencies/{minimum,latest}/c/{almalinux8,centos7,fedora36,opensuse_leap15,ubuntu20.04}/amd64/
  - &generate_pipeline
    # Add the series of mirrors that the main jobs are expected to pull from
    - >-
      test "$CI_COMMIT_REF_PROTECTED" = "true"
      && SBCACHE_ROOT=protected
      || SBCACHE_ROOT=nonprotected
    - >-
      test -n "$CI_MERGE_REQUEST_IID"
      && SBCACHE_DIR="mr${CI_MERGE_REQUEST_IID}_${CI_COMMIT_REF_SLUG}"
      || SBCACHE_DIR="$CI_COMMIT_REF_SLUG"
    - >-
      spack mirror add --scope site
      --s3-access-key-id "${SBCACHE_AWS_ID:-$SBCACHE_AWS_ID_NP}"
      --s3-access-key-secret "${SBCACHE_AWS_SECRET:-$SBCACHE_AWS_SECRET_NP}"
      destination "$SBCACHE_SCHEMA://$SBCACHE_BUCKET/$SBCACHE_ROOT/$SBCACHE_DIR"
    - >-
      test "$CI_MERGE_REQUEST_TARGET_BRANCH_PROTECTED" = "true"
      && spack mirror add --scope site
      --s3-access-key-id "${SBCACHE_AWS_ID:-$SBCACHE_AWS_ID_NP}"
      --s3-access-key-secret "${SBCACHE_AWS_SECRET:-$SBCACHE_AWS_SECRET_NP}"
      main-target "$SBCACHE_SCHEMA://$SBCACHE_BUCKET/protected/$CI_MERGE_REQUEST_TARGET_BRANCH_NAME"
      || true
    - spack mirror list
    # Generate (and then adjust) the single pipeline
    - spack env activate --without-view ci/dependencies/merged-cache/
    - >-
      spack ci generate
      --optimize
      --check-index-only
      --buildcache-destination "$SBCACHE_SCHEMA://$SBCACHE_BUCKET/$SBCACHE_ROOT/$SBCACHE_DIR"
      --artifacts-root spack-ci-artifacts
      --output-file spack-ci-artifacts/ci.yml
    # We need to adjust the pipeline manually to fill in parts that aren't able to be set otherwise.
    # https://github.com/spack/spack/pull/32300 will help with this.
    - >-
      PYTHONPATH=$SPACK_ROOT/lib/spack/external python3 ci/dependencies/fixpipe.py
      spack-ci-artifacts/ci.yml
      --add-globals '{workflow: {rules: [{when: always}]}}'
      --add-to-jobs '{cache: [
      {key: spack, paths: [.spack.git], when: always},
      {key: depsjob-$CI_JOB_IMAGE, paths: [.spack-bincache/], when: always},
      ]}'
      --ignore-job no-specs-to-rebuild

  artifacts: &pipeline_artifacts
    paths:
    - spack-ci-artifacts

generate_deps.arm64:
  stage: dependencies
  extends: .spack
  needs:
  # - 'concretize_deps.arm64: [almalinux8]'
  # - 'concretize_deps.arm64: [fedora36]'
  - 'concretize_deps.arm64: [ubuntu20.04, gcc@9]'

  script:
  # Fuse the now-concrete environments into one
  - python3 ci/dependencies/merged-cache/fuse.py
    ci/dependencies/{minimum,latest}/c/ubuntu20.04/arm64/
    # ci/dependencies/{minimum,latest}/c/{almalinux8,fedora36,ubuntu20.04}/arm64/
  - *generate_pipeline

  artifacts: *pipeline_artifacts

# Launch the generated pipeline as a child. We require that it works before
# moving on so that we never build dependencies in our later jobs.
build_deps.amd64:
  stage: dependencies
  needs: [generate_deps.amd64]
  trigger:
    strategy: depend
    include:
    - job: generate_deps.amd64
      artifact: spack-ci-artifacts/ci.yml
build_deps.arm64:
  stage: dependencies
  needs: [generate_deps.arm64]
  trigger:
    strategy: depend
    include:
    - job: generate_deps.arm64
      artifact: spack-ci-artifacts/ci.yml
